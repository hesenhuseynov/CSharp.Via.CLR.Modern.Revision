1.1 Compiling Source Code into Managed Modules — Modern .NET 8/9 Edition When you begin building an application on modern .NET (versions 5 through 9), the first architectural step remains identical to what the original CLR design established more than two decades ago: you write source code in a high-level language, and a compiler processes that source into a managed module. A managed module contains two fundamental components: Intermediate Language (IL) — a CPU-agnostic instruction set Metadata — rich structural information describing all types, members, signatures, and references Although this model originated in the .NET Framework era, modern .NET expands it dramatically with cross-platform execution, improved compilation tools, new runtime optimizations, and optional native-only deployment models. Choosing a Language Historically, languages differed significantly in capability: native C/C++ provided extremely low-level control (manual memory management, direct thread creation, raw pointers), while Visual Basic enabled rapid GUI and COM development with higher-level abstractions. The Common Language Runtime changed this landscape. Language choice now affects only syntax and developer productivity, not runtime capability. The CLR provides all languages with: memory management (garbage collection) exception handling thread creation and synchronization assembly loading security enforcement At runtime, the CLR has no knowledge of which language produced the module — it sees only IL + metadata. Therefore, modern .NET developers choose languages based on expressiveness and tooling, rather than runtime differences. Modern .NET officially supports: C# (Roslyn) F# Visual Basic IL Assembler (ilasm.exe) Languages like IronPython and IronRuby are unmaintained today. C++/CLI exists only in the Windows-only .NET Framework and is not part of .NET 5–9. How Modern Compilers Produce Managed Modules Regardless of the source language, all modern .NET compilers follow the same conceptual steps: Parse the source code and build an abstract syntax tree Perform semantic analysis (type checking, overload resolution, generics validation) Emit IL instructions that describe program behavior Emit rich metadata describing: types methods fields parameters generics attributes referenced assemblies The output is a managed module (DLL or EXE) containing: IL Metadata CLR Header Optional resources This module is the smallest physical unit the CLR can load and execute. Roslyn, the modern compiler platform, adds features that did not exist in earlier .NET versions: incremental compilation analyzers refactorings source generators semantic models Yet the final output — IL + metadata — remains consistent with the original CLR design. Managed Modules Are Not Always PE Files Anymore In the .NET Framework era, all managed modules used Windows PE32/PE32+ format because the runtime existed only on Windows. Modern .NET is cross-platform: Platform Module Format Windows PE32 / PE32+ Linux ELF macOS Mach-O Additional behaviors: Single-file publishing bundles modules into one executable and extracts them at runtime NativeAOT can eliminate IL entirely and generate a fully native binary Thus, the older statement “a managed module is a PE file” now applies only to Windows-specific builds. Runtime Interpretation of IL and Metadata At execution time, the CLR: Loads the managed module Reads metadata to understand type layouts, method signatures, references, generics Verifies that IL is type-safe (if verification is enabled) JIT-compiles IL into native CPU instructions Executes the native code Modern .NET includes advanced optimizations: Tiered JIT — initial “quick” compilation, then optimized recompilation On-Stack Replacement (OSR) — hot loops recompiled while running Profile-guided optimizations These features did not exist in the original CLR era and greatly improve runtime throughput. Metadata: The Backbone of Managed Execution Metadata is a structured set of tables stored alongside IL. It describes both: what the module defines (types, members) what the module references (external types) Metadata enables: IntelliSense and IDE tooling Reflection Serialization Dynamic code generation GC root tracking (knowing which fields reference objects) JIT code verification Language interop Because metadata is embedded directly into the module, IL and metadata can never fall out of sync. Managed vs Unmanaged Code Native languages (C, C++, Rust) compile directly into CPU-specific instructions. Managed languages (C#, F#, VB) compile into IL, giving .NET: portability runtime verification GC memory management runtime optimizations safer execution C++/CLI was historically the only language capable of mixing managed and unmanaged code in the same module. Modern .NET instead promotes clearer separation using: P/Invoke reverse P/Invoke function pointers (delegate*) NativeAOT interop Security: DEP and ASLR All managed modules automatically benefit from OS-level security features: Data Execution Prevention (DEP) Address Space Layout Randomization (ASLR) These are enforced by Windows, Linux, and macOS, and require no explicit configuration from .NET developers. Summary The foundational idea introduced in the original CLR — compiling high-level language code into IL + metadata — remains the core of modern .NET. But the ecosystem has evolved dramatically: cross-platform file formats (PE, ELF, Mach-O) Roslyn and advanced compiler tooling Tiered JIT + OSR runtime optimizations NativeAOT native-only binaries cleaner interop models Even with these advancements, the managed module remains the fundamental building block of .NET execution.
